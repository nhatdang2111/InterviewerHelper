"""Interviewer Helper - Main Application"""
import gradio as gr
import tempfile
from pathlib import Path
from datetime import datetime

from core.pdf_parser import extract_text_from_pdf, is_image_based_pdf, get_pdf_as_bytes
from core.ai_client import AIClient
from core.question_generator import analyze_cv, analyze_cv_from_pdf, generate_interview_questions
from core.cv_scorer import score_cv
from storage.database import Database
from storage.models import CVRecord, Settings
from ui.i18n import get_text, set_language, LANGUAGES


# Initialize database and migrate existing plaintext keys
db = Database()
db.migrate_plaintext_keys()


def load_saved_settings():
    """Load settings from database"""
    return db.load_settings()


def create_ai_client(settings: Settings) -> AIClient:
    """Create AI client from settings"""
    return AIClient(
        claude_key=settings.claude_api_key,
        gemini_key=settings.gemini_api_key
    )


def process_cv(
    pdf_file,
    jd_text: str,
    jd_required: str,
    jd_nice_to_have: str,
    jd_experience: str,
    jd_mode: str,
    model: str,
    candidate_name: str,
    position: str,
    claude_key: str,
    gemini_key: str
):
    """Main processing function"""
    try:
        # Build JD text
        if jd_mode == "Structured":
            jd_full = f"""
## Required Skills
{jd_required}

## Nice to Have
{jd_nice_to_have}

## Experience Required
{jd_experience} years
"""
        else:
            jd_full = jd_text

        # Create AI client
        ai_client = AIClient(claude_key=claude_key, gemini_key=gemini_key)

        # Check if PDF is image-based (scanned) or has text layer
        pdf_path = pdf_file.name
        cv_text = extract_text_from_pdf(pdf_path)

        # Analyze CV - use direct PDF vision if text extraction fails
        if cv_text.strip():
            # PDF has text layer - use text-based analysis
            cv_summary = analyze_cv(ai_client, cv_text, model.lower())
        else:
            # Image-based PDF - use AI vision to read directly
            pdf_bytes = get_pdf_as_bytes(pdf_path)
            cv_summary = analyze_cv_from_pdf(ai_client, pdf_bytes, model.lower())
            cv_text = "[Image-based PDF - analyzed via AI vision]"

        # Generate questions
        questions = generate_interview_questions(ai_client, cv_summary, jd_full, model.lower())

        # Score CV
        score_result = score_cv(ai_client, cv_summary, jd_full, model.lower())
        overall_score = score_result.get("overall_score", 0)

        # Save to history
        record = CVRecord(
            candidate_name=candidate_name or "Unknown",
            position=position or "Unknown",
            cv_text=cv_text,
            cv_summary=cv_summary,
            jd_text=jd_full,
            questions=questions,
            score=overall_score,
            score_breakdown=str(score_result)
        )
        db.save_cv_record(record)

        # Build output markdown
        output = f"""# Interview Questions: {candidate_name or 'Candidate'}

**Position:** {position or 'N/A'}
**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M')}
**Score:** {overall_score}/100

---

## CV Summary

{cv_summary}

---

## Job Description

{jd_full}

---

## Interview Questions

{questions}

---

## Score Breakdown

```json
{score_result}
```

---

*Generated by Interviewer Helper*
"""
        return output, f"‚úÖ Generated! Score: {overall_score}/100"

    except Exception as e:
        return f"Error: {str(e)}", f"‚ùå Error: {str(e)}"


def save_settings(claude_key, gemini_key, default_model, language):
    """Save settings to database"""
    settings = Settings(
        claude_api_key=claude_key,
        gemini_api_key=gemini_key,
        default_model=default_model.lower(),
        language=language
    )
    db.save_settings(settings)
    set_language(language)
    return "‚úÖ Settings saved!"


def get_history_data():
    """Get history for display"""
    records = db.get_all_records()
    data = []
    for r in records:
        data.append([
            r.created_at,
            r.candidate_name,
            r.position,
            r.score,
            r.id
        ])
    return data


def view_record(record_id):
    """View a saved record"""
    if not record_id:
        return "Select a record to view"
    record = db.get_record(int(record_id))
    if record:
        return record.questions
    return "Record not found"


def delete_record(record_id):
    """Delete a record"""
    if record_id:
        db.delete_record(int(record_id))
    return get_history_data()


def create_md_download(content: str, candidate_name: str, language: str = "en"):
    """Create downloadable markdown file with bilingual headers"""
    if not content or content.startswith("Error"):
        return None

    # Bilingual headers mapping
    headers = {
        "en": {
            "interview_questions": "Interview Questions",
            "position": "Position",
            "generated": "Generated",
            "score": "Score",
            "cv_summary": "CV Summary",
            "job_description": "Job Description",
            "questions": "Interview Questions",
            "score_breakdown": "Score Breakdown",
            "footer": "Generated by Interviewer Helper"
        },
        "vi": {
            "interview_questions": "C√¢u H·ªèi Ph·ªèng V·∫•n",
            "position": "V·ªã Tr√≠",
            "generated": "Ng√†y T·∫°o",
            "score": "ƒêi·ªÉm",
            "cv_summary": "T√≥m T·∫Øt CV",
            "job_description": "M√¥ T·∫£ C√¥ng Vi·ªác",
            "questions": "C√¢u H·ªèi Ph·ªèng V·∫•n",
            "score_breakdown": "Chi Ti·∫øt ƒêi·ªÉm",
            "footer": "T·∫°o b·ªüi Interviewer Helper"
        }
    }

    h = headers.get(language, headers["en"])

    # Replace English headers with localized ones if Vietnamese
    if language == "vi":
        content = content.replace("# Interview Questions:", f"# {h['interview_questions']}:")
        content = content.replace("**Position:**", f"**{h['position']}:**")
        content = content.replace("**Generated:**", f"**{h['generated']}:**")
        content = content.replace("**Score:**", f"**{h['score']}:**")
        content = content.replace("## CV Summary", f"## {h['cv_summary']}")
        content = content.replace("## Job Description", f"## {h['job_description']}")
        content = content.replace("## Interview Questions", f"## {h['questions']}")
        content = content.replace("## Score Breakdown", f"## {h['score_breakdown']}")
        content = content.replace("*Generated by Interviewer Helper*", f"*{h['footer']}*")

    # Create temp file
    safe_name = "".join(c for c in (candidate_name or "candidate") if c.isalnum() or c in " -_").strip()
    safe_name = safe_name.replace(" ", "_") or "interview"
    timestamp = datetime.now().strftime("%Y%m%d_%H%M")
    filename = f"{safe_name}_{timestamp}.md"

    # Write to temp file
    temp_dir = tempfile.gettempdir()
    filepath = Path(temp_dir) / filename
    filepath.write_text(content, encoding="utf-8")

    return str(filepath)


def build_app():
    """Build Gradio interface"""
    settings = load_saved_settings()

    with gr.Blocks(title="Interviewer Helper", theme=gr.themes.Soft()) as app:
        gr.Markdown("# üéØ Interviewer Helper")

        with gr.Tabs():
            # Tab 1: Generate Questions
            with gr.Tab("üìù Generate Questions"):
                with gr.Row():
                    with gr.Column(scale=1):
                        pdf_input = gr.File(
                            label="Upload CV (PDF)",
                            file_types=[".pdf"]
                        )
                        candidate_name = gr.Textbox(
                            label="Candidate Name",
                            placeholder="e.g., Nguyen Van A"
                        )
                        position = gr.Textbox(
                            label="Position",
                            placeholder="e.g., Senior Backend Developer"
                        )
                        model_select = gr.Radio(
                            choices=["Gemini", "Claude"],
                            value="Gemini",
                            label="AI Model"
                        )

                    with gr.Column(scale=2):
                        jd_mode = gr.Radio(
                            choices=["Free Text", "Structured"],
                            value="Free Text",
                            label="JD Format"
                        )

                        # Free text mode
                        jd_text = gr.Textbox(
                            label="Job Description",
                            placeholder="Paste job description here...",
                            lines=10,
                            visible=True
                        )

                        # Structured mode
                        with gr.Group(visible=False) as structured_group:
                            jd_required = gr.Textbox(
                                label="Required Skills",
                                placeholder="e.g., .NET, C#, SQL Server...",
                                lines=3
                            )
                            jd_nice_to_have = gr.Textbox(
                                label="Nice to Have",
                                placeholder="e.g., Azure, Docker, Kubernetes...",
                                lines=2
                            )
                            jd_experience = gr.Number(
                                label="Years of Experience",
                                value=5
                            )

                        def toggle_jd_mode(mode):
                            return (
                                gr.update(visible=mode == "Free Text"),
                                gr.update(visible=mode == "Structured")
                            )

                        jd_mode.change(
                            toggle_jd_mode,
                            inputs=[jd_mode],
                            outputs=[jd_text, structured_group]
                        )

                generate_btn = gr.Button("üöÄ Generate Questions", variant="primary")
                status = gr.Textbox(label="Status", interactive=False)

                output_md = gr.Markdown(label="Generated Questions")
                output_content_state = gr.State("")  # Store generated content for download

                with gr.Row():
                    download_btn = gr.Button("üì• Download .md")
                    download_file = gr.File(label="Download", visible=False)

                # Hidden inputs for API keys and language
                claude_key_state = gr.State(settings.claude_api_key)
                gemini_key_state = gr.State(settings.gemini_api_key)
                language_state = gr.State(settings.language or "en")

                def process_and_store(pdf_file, jd_text, jd_required, jd_nice_to_have,
                                      jd_experience, jd_mode, model, name, pos,
                                      claude_key, gemini_key):
                    """Process CV and return result + store content"""
                    output, stat = process_cv(
                        pdf_file, jd_text, jd_required, jd_nice_to_have,
                        jd_experience, jd_mode, model, name, pos,
                        claude_key, gemini_key
                    )
                    return output, stat, output  # Third output is for state

                generate_btn.click(
                    process_and_store,
                    inputs=[
                        pdf_input, jd_text, jd_required, jd_nice_to_have,
                        jd_experience, jd_mode, model_select,
                        candidate_name, position,
                        claude_key_state, gemini_key_state
                    ],
                    outputs=[output_md, status, output_content_state]
                )

                def handle_download(content, name, lang):
                    """Handle download button click"""
                    filepath = create_md_download(content, name, lang)
                    if filepath:
                        return gr.update(value=filepath, visible=True)
                    return gr.update(visible=False)

                download_btn.click(
                    handle_download,
                    inputs=[output_content_state, candidate_name, language_state],
                    outputs=[download_file]
                )

            # Tab 2: History
            with gr.Tab("üìö History"):
                history_table = gr.Dataframe(
                    headers=["Date", "Candidate", "Position", "Score", "ID"],
                    value=get_history_data(),
                    interactive=False
                )
                refresh_btn = gr.Button("üîÑ Refresh")
                refresh_btn.click(get_history_data, outputs=[history_table])

                with gr.Row():
                    record_id_input = gr.Number(label="Record ID", precision=0)
                    view_btn = gr.Button("üëÅÔ∏è View")
                    delete_btn = gr.Button("üóëÔ∏è Delete", variant="stop")

                record_view = gr.Markdown()

                view_btn.click(view_record, inputs=[record_id_input], outputs=[record_view])
                delete_btn.click(delete_record, inputs=[record_id_input], outputs=[history_table])

            # Tab 3: Compare (placeholder)
            with gr.Tab("üìä Compare CVs"):
                gr.Markdown("### Compare Multiple CVs")
                gr.Markdown("*Coming soon - Select CVs from history to compare side-by-side*")

            # Tab 4: Settings
            with gr.Tab("‚öôÔ∏è Settings"):
                claude_key_input = gr.Textbox(
                    label="Claude API Key",
                    value=settings.claude_api_key,
                    type="password"
                )
                gemini_key_input = gr.Textbox(
                    label="Gemini API Key",
                    value=settings.gemini_api_key,
                    type="password"
                )
                default_model_input = gr.Radio(
                    choices=["Gemini", "Claude"],
                    value=settings.default_model.capitalize() if settings.default_model else "Gemini",
                    label="Default AI Model"
                )
                language_input = gr.Dropdown(
                    choices=list(LANGUAGES.keys()),
                    value=settings.language or "en",
                    label="Language"
                )

                save_btn = gr.Button("üíæ Save Settings", variant="primary")
                settings_status = gr.Textbox(label="Status", interactive=False)

                save_btn.click(
                    save_settings,
                    inputs=[claude_key_input, gemini_key_input, default_model_input, language_input],
                    outputs=[settings_status]
                )

                # Update state when settings saved
                def update_states(claude, gemini, lang):
                    return claude, gemini, lang

                save_btn.click(
                    update_states,
                    inputs=[claude_key_input, gemini_key_input, language_input],
                    outputs=[claude_key_state, gemini_key_state, language_state]
                )

    return app


if __name__ == "__main__":
    app = build_app()
    app.launch(
        server_name="127.0.0.1",
        server_port=7860,
        share=False,
        inbrowser=True
    )
